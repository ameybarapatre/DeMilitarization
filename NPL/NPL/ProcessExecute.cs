//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Reflection;
using System.Threading;
using Gtk;

namespace NPL
{
	public class ProcessExecute
	{	private MainWindow m;
        public static String g;
        ThreadNotify d;
        private string rule;
        public ProcessExecute ( MainWindow main,String rule1)
		{ m = main;
            rule = rule1;
            Thread s = new Thread(new ThreadStart(execute));
           d = new ThreadNotify (new ReadyEvent (m.Disconnect));
            s.Start();
        }


        public void execute()
        {
            try
            {
                // create the ProcessStartInfo using "cmd" as the program to be run,
                // and "/c " as the parameters.
                // Incidentally, /c tells cmd that we want it to execute the command that follows,
                // and then exit.
                System.Diagnostics.ProcessStartInfo procStartInfo =
                new System.Diagnostics.ProcessStartInfo("cmd", "/c " +rule);
                //iptables -A OUTPUT -p icmp -o eth0 -j ACCEPT          
                //iptables -A INPUT -p icmp --icmp-type echo-reply -s 0/0 -i eth0 -j ACCEPT     
                //iptables -A INPUT -p icmp --icmp-type destination-unreachable -s 0/0 -i eth0 -j ACCEPT  
                //iptables -A INPUT -p icmp --icmp-type time-exceeded -s 0/0 -i eth0 -j ACCEPT       
                //iptables -A INPUT -p icmp -i eth0 -j DROP      
                
                // The following commands are needed to redirect the standard output.
                // This means that it will be redirected to the Process.StandardOutput StreamReader.
                procStartInfo.RedirectStandardOutput = true;
                procStartInfo.UseShellExecute = false;
                // Do not create the black window.
                procStartInfo.CreateNoWindow = true;
                // Now we create a process, assign its ProcessStartInfo and start itm
                System.Diagnostics.Process proc = new System.Diagnostics.Process();
                proc.StartInfo = procStartInfo;
                proc.Start();
                // Get the output into a string
                string result = proc.StandardOutput.ReadToEnd();
                // Display the command output.
                Console.WriteLine(result);
                g=result;
            }
            catch (Exception objException)
            {
                d.WakeupMain ();
                // Log the exception
            }
        }
	}

}

